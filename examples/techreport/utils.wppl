// Common stuff goes here so we don't clog up the examples with hard-to-read stuff
// (and so refactoring is easier if we change stuff later on)


// Scalars vs. tensors

// Turn single-element vector into a scalar
var toscalar = function(vec) {
	return T.get(vec, 0);
};

var isNumberOrScalarNode = function(x) {
	return (typeof x === 'number') || (ad.isLifted(x) && (typeof ad.value(x) === 'number'));
};


// Parameters

var paramScalar = function() {
	return scalarParam(0, 0.1);
};

var paramVector = function(n) {
	return param([n, 1], 0, 0.1);
};

var paramMatrix = function(n, m) {
	return param([n, m], 0, 0.1);
};

var perceptronParams = function(opts) {
	return {
		W_hidden: paramMatrix(opts.nHidden, opts.nIn),
		b_hidden: paramVector(opts.nHidden),
		W_out: paramMatrix(opts.nOut, opts.nHidden),
		b_out: paramVector(opts.nOut)
	};
};


// Neural network layers, etc.

var linear = function(x, W, b) {
	return T.add(T.dot(W, x), b);
};

var softplus = function(x) {
	return isNumberOrScalarNode(x) ?
		Math.log(Math.exp(x) + 1) :
		T.log(T.add(T.exp(x), 1));
};

var sigmoid = function(x) { 
	return isNumberOrScalarNode(x) ?
		Math.sigmoid(x) :
		T.sigmoid(x);
};

var perceptron = function(x, params) {
	var hidden = sigmoid(linear(x, params.W_hidden, params.b_hidden));
	return linear(hidden, params.W_out, params.b_out);
};


// Misc.

var mean = function(xs) {
	return sum(xs) / xs.length;
};

var variance = function(xs, optmean) {
	var m = optmean == undefined ? mean(xs) : optmean;
	return reduce(function(x, acc) {
		var diff = x - m;
		return diff*diff + acc;
	}, 0, xs) / xs.length;
};

var stddev = function(xs, optmean) {
	return Math.sqrt(variance(xs, optmean));
};

var standardize = function(x, moments) {
	return (x - moments.mu) / moments.sigma;
};
